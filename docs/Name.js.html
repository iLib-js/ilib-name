<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Name.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Name.html">Name</a><ul class='methods'><li data-type='method'><a href="Name.html#.create">create</a></li><li data-type='method'><a href="Name.html#clone">clone</a></li><li data-type='method'><a href="Name.html#getSortFamilyName">getSortFamilyName</a></li></ul></li><li><a href="NameFmt.html">NameFmt</a><ul class='methods'><li data-type='method'><a href="NameFmt.html#.create">create</a></li><li data-type='method'><a href="NameFmt.html#format">format</a></li><li data-type='method'><a href="NameFmt.html#getComponents">getComponents</a></li><li data-type='method'><a href="NameFmt.html#getLocale">getLocale</a></li><li data-type='method'><a href="NameFmt.html#getStyle">getStyle</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Name.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Name.js - Person name parser
 *
 * Copyright © 2013-2015, 2018, 2021-2022 JEDLSoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// notes:
// icelandic given names: http://en.wiktionary.org/wiki/Appendix:Icelandic_given_names
// danish approved given names: http://www.familiestyrelsen.dk/samliv/navne/
// http://www.mentalfloss.com/blogs/archives/59277
// other countries with first name restrictions: Norway, China, New Zealand, Japan, Sweden, Germany, Hungary

import { Path, Utils, JSUtils } from 'ilib-common';
import Locale from 'ilib-locale';
import IString from 'ilib-istring';
import { withinRange, isAlpha, isIdeo, isPunct, isSpace } from 'ilib-ctype';
import getLocaleData, { LocaleData } from 'ilib-localedata';
import { getPlatform } from 'ilib-env';

function localeDir() {
    switch (getPlatform()) {
        case "nodejs":
            return Path.join(Path.dirname((typeof(module) !== 'undefined') ? module.id : Path.fileUriToPath(import.meta.url)),
                "../locale");

        case "browser":
            return "../assembled";

        default:
            return "../locale";
    }
}

/**
 * @class
 * A class to parse names of people. Different locales have different conventions when it
 * comes to naming people.&lt;p>
 *
 */
class Name {
    /**
     * Create a new instance of a Name. This parses the name and puts the result in the various
     * fields.&lt;p>
     *
     * The options can contain any of the following properties:
     *
     * &lt;ul>
     * &lt;li>&lt;i>locale&lt;/i> - use the rules and conventions of the given locale in order to parse
     * the name
     * &lt;li>&lt;i>style&lt;/i> - explicitly use the named style to parse the name. Valid values so
     * far are "western" and "asian". If this property is not specified, then the style will
     * be gleaned from the name itself. This class will count the total number of Latin or Asian
     * characters. If the majority of the characters are in one style, that style will be
     * used to parse the whole name.
     * &lt;li>&lt;i>order&lt;/i> - explicitly use the given order for names. In some locales, such
     * as Russian, names may be written equally validly as "givenName familyName" or "familyName
     * givenName". This option tells the parser which order to prefer, and overrides the
     * default order for the locale. Valid values are "gf" (given-family) or "fg" (family-given).
     * &lt;li>&lt;i>useSpaces&lt;/i> - explicitly specifies whether to use spaces or not between the given name , middle name
     * and family name.
     * &lt;li>&lt;i>compoundFamilyName&lt;/i> - for Asian and some other types of names, search for compound
     * family names. If this parameter is not specified, the default is to use the setting that is
     * most common for the locale. If it is specified, the locale default is
     * overridden with this flag.
     * &lt;/ul>
     *
     * Additionally, a name instance can be constructed by giving the explicit
     * already-parsed fields or by using another name instance as the parameter. (That is,
     * it becomes a copy constructor.) The name fields can be any of the following:
     *
     * &lt;ul>
     * &lt;li>&lt;i>prefix&lt;/i> - the prefix prepended to the name
     * &lt;li>&lt;i>givenName&lt;/i> - the person's given or "first" name
     * &lt;li>&lt;i>middleName&lt;/i> - one or more middle names, separated by spaces even if the
     * language doesn't use usually use spaces. The spaces are merely separators.
     * &lt;li>&lt;i>familyName&lt;/i> - one or more family or "last" names, separated by spaces
     * even if the language doesn't use usually use spaces. The spaces are merely separators.
     * &lt;li>&lt;i>suffix&lt;/i> - the suffix appended to the name
     * &lt;li>&lt;i>honorific&lt;/i> - the honorific title of the name. This could be formatted
     * as a prefix or a suffix, depending on the customs of the particular locale. You
     * should only give either an honorific or a prefix/suffix, but not both.
     * &lt;/ul>
     *
     * When the parser has completed its parsing, it fills in the same fields as listed
     * above.&lt;p>
     *
     * For names that include auxilliary words, such as the family name "van der Heijden", all
     * of the auxilliary words ("van der") will be included in the field.&lt;p>
     *
     * For names in some Spanish locales, it is assumed that the family name is doubled. That is,
     * a person may have a paternal family name followed by a maternal family name. All
     * family names will be listed in the familyName field as normal, separated by spaces.
     * When formatting the short version of such names, only the paternal family name is used.
     *
     * @constructor
     * @param {string|Name|Object=} name the name to parse
     * @param {Object=} options Options governing the construction of this name instance
     */
    constructor(name, options) {
        if (!options || !options._noinit) {
            this.init(name, options, true);
        }
    }

    /**
     * Initialize this instance.
     * @private
     */
    init(name, options, sync) {
        if (!name || name.length === 0) {
            return sync ? undefined : Promise.resolve(this);
        }

        if (options) {
            if (options.locale) {
                this.locale = (typeof (options.locale) === 'string') ? new Locale(options.locale) : options.locale;
            }

            if (options.style &amp;&amp; (options.style === "asian" || options.style === "western")) {
                this.style = options.style;
            }

            if (options.order &amp;&amp; (options.order === "gmf" || options.order === "fmg" || options.order === "fgm")) {
                this.order = options.order;
            }

            if (typeof(options.sync) === 'boolean') {
                sync = options.sync;
            }

            if (typeof(options.compoundFamilyName) !== 'undefined') {
                this.singleFamilyName = !options.compoundFamilyName;
            }
        }

        this.locale = this.locale || new Locale();

        if (typeof (name) === 'object') {
            // copy constructor -- don't need to load anything
            /**
             * The prefixes for this name
             * @type {string|Array.&lt;string>}
             */
            this.prefix = name.prefix;
            /**
             * The given (personal) name in this name.
             * @type {string|Array.&lt;string>}
             */
            this.givenName = name.givenName;
            /**
             * The middle names used in this name. If there are multiple middle names, they all
             * appear in this field separated by spaces.
             * @type {string|Array.&lt;string>}
             */
            this.middleName = name.middleName;
            /**
             * The family names in this name. If there are multiple family names, they all
             * appear in this field separated by spaces.
             * @type {string|Array.&lt;string>}
             */
            this.familyName = name.familyName;
            /**
             * The suffixes for this name. If there are multiple suffixes, they all
             * appear in this field separated by spaces.
             * @type {string|Array.&lt;string>}
             */
            this.suffix = name.suffix;
            /**
             * The honorific title for this name. This honorific will be used as the prefix
             * or suffix as dictated by the locale
             * @type {string|Array.&lt;string>}
             */
            this.honorific = name.honorific;

            // private properties
            this.locale = name.locale;
            this.style = name.style;
            this.order = name.order;
            this.useSpaces = name.useSpaces;
            this.isAsianName = name.isAsianName;

            return sync ? undefined : Promise.resolve(this);
        }

        const locData = getLocaleData({
            path: localeDir(),
            sync
        });

        if (sync) {
            try {
                this.info = locData.loadData({
                    basename: "name",
                    locale: this.locale,
                    sync: sync
                });
            } catch (e) {
                this.info = Name.defaultInfo[this.style || "western"];
            }
            this._initialize(name);
        } else {
            return locData.loadData({
                basename: "name",
                locale: this.locale,
                sync: sync
            }).then((info) => {
                this.info = info || Name.defaultInfo[this.style || "western"];
                this._initialize(name);
                return this;
            }).catch((e) => {
                this.info = Name.defaultInfo[this.style || "western"];
                this._initialize(name);
                return this;
            });
        }
    }

    /**
     * Factory method to create a new instance of Name asynchronously.
     * The parameters are the same as for the constructor, but it returns
     * a `Promise` instead of the instance directly.
     *
     * @param {string} name the name to parse
     * @param {Object} options the same objects you would send to a constructor
     * @returns {Promise} a promise to load a Name instance. The resolved
     * value of the promise is the new instance of Name,
     */
    static create(name, options) {
        const n = new Name(undefined, { ...options, _noinit: true });
        return n.init(name, options, false);
    }

    static defaultInfo = {
        "western": {
            "components": {
                "short": "gf",
                "medium": "gmf",
                "long": "pgmf",
                "full": "pgmfs",
                "formal_short": "hf",
                "formal_long": "hgf"
            },
            "format": "{prefix} {givenName} {middleName} {familyName}{suffix}",
            "sortByHeadWord": false,
            "nameStyle": "western",
            "conjunctions": {
                "and1": "and",
                "and2": "and",
                "or1": "or",
                "or2": "or"
            },
            "auxillaries": {
                "von": 1,
                "von der": 1,
                "von den": 1,
                "van": 1,
                "van der": 1,
                "van de": 1,
                "van den": 1,
                "de": 1,
                "di": 1,
                "la": 1,
                "lo": 1,
                "des": 1,
                "le": 1,
                "les": 1,
                "du": 1,
                "de la": 1,
                "del": 1,
                "de los": 1,
                "de las": 1
            },
            "prefixes": [
                "doctor",
                "dr",
                "mr",
                "mrs",
                "ms",
                "mister",
                "madame",
                "madamoiselle",
                "miss",
                "monsieur",
                "señor",
                "señora",
                "señorita"
            ],
            "suffixes": [
                ",",
                "junior",
                "jr",
                "senior",
                "sr",
                "i",
                "ii",
                "iii",
                "esq",
                "phd",
                "md"
            ],
            "patronymicName":[ ],
            "familyNames":[ ]
        },
        "asian": {
            "components": {
                "short": "gf",
                "medium": "gmf",
                "long": "hgmf",
                "full": "hgmf",
                "formal_short": "hf",
                "formal_long": "hgf"
            },
            "format": "{prefix}{familyName}{middleName}{givenName}{suffix}",
            "nameStyle": "asian",
            "sortByHeadWord": false,
            "conjunctions": {},
            "auxillaries": {},
            "prefixes": [],
            "suffixes": [],
            "patronymicName":[],
            "familyNames":[]
        }
    }

    /**
     * Return true if the given character is in the range of the Han, Hangul, or kana
     * scripts.
     * @static
     * @private
     */
    static _isAsianChar(c) {
        return isIdeo(c) ||
            withinRange(c, "hangul") ||
            withinRange(c, "hiragana") ||
            withinRange(c, "katakana");
    }

    /**
     * @static
     * @private
     */
    static _isAsianName(name, language) {
        // the idea is to count the number of asian chars and the number
        // of latin chars. If one is greater than the other, choose
        // that style.
        let asian = 0,
            latin = 0,
            i;

        if (name &amp;&amp; name.length > 0) {
            for (i = 0; i &lt; name.length; i++) {
                let c = name.charAt(i);

                if (Name._isAsianChar(c)) {
                    if (language =="ko" || language =="ja" || language =="zh") {
                        return true;
                    }
                    asian++;
                } else if (isAlpha(c)) {
                    if (!language =="ko" || !language =="ja" || !language =="zh") {
                        return false;
                    }
                    latin++;
                }
            }

            return latin &lt; asian;
        }

        return false;
    }

    /**
     * Return true if any Latin letters are found in the string. Return
     * false if all the characters are non-Latin.
     * @static
     * @private
     */
    static _isEuroName(name, language) {
        let c,
            n = new IString(name, {locale: language}),
            it = n.charIterator();

        while (it.hasNext()) {
            c = it.next();

            if (!Name._isAsianChar(c) &amp;&amp; !isPunct(c) &amp;&amp; !isSpace(c)) {
                return true;
            } else if (Name._isAsianChar(c) &amp;&amp; (language =="ko" || language =="ja" || language =="zh")) {
                return false;
            }
        }
        return false;
    }

    /**
     * @private
     */
    _initialize(name) {
        let parts, prefixArray, prefix, prefixLower,
            suffixArray, suffix, suffixLower,
            i, info, hpSuffix;
        let currentLanguage = this.locale.getLanguage();

        if (name) {
            // for DFISH-12905, pick off the part that the LDAP server automatically adds to our names in HP emails
            i = name.search(/\s*[,\/\(\[\{&lt;]/);
            if (i !== -1) {
                hpSuffix = name.substring(i);
                hpSuffix = hpSuffix.replace(/\s+/g, ' '); // compress multiple whitespaces
                suffixArray = hpSuffix.split(" ");
                let conjunctionIndex = this._findLastConjunction(suffixArray);
                if (conjunctionIndex > -1) {
                    // it's got conjunctions in it, so this is not really a suffix
                    hpSuffix = undefined;
                } else {
                    name = name.substring(0, i);
                }
            }

            this.isAsianName = Name._isAsianName(name, currentLanguage);
            if (this.info.nameStyle === "asian") {
                info = this.isAsianName ? this.info : Name.defaultInfo.western;
            } else {
                info = this.isAsianName ? Name.defaultInfo.asian : this.info;
            }

            if (this.isAsianName) {
                // all-asian names
                if (this.useSpaces === false) {
                    name = name.replace(/\s+/g, ''); // eliminate all whitespaces
                }
                parts = name.trim().split('');
            }
            //}
            else {
                name = name.replace(/, /g, ' , ');
                name = name.replace(/\s+/g, ' '); // compress multiple whitespaces
                parts = name.trim().split(' ');
            }

            // check for prefixes
            if (parts.length > 1) {
                for (i = parts.length; i > 0; i--) {
                    prefixArray = parts.slice(0, i);
                    prefix = prefixArray.join(this.isAsianName ? '' : ' ');
                    prefixLower = prefix.toLowerCase();
                    prefixLower = prefixLower.replace(/[,\.]/g, ''); // ignore commas and periods
                    if (JSUtils.isArray(this.info.prefixes) &amp;&amp;
                        (JSUtils.indexOf(this.info.prefixes, prefixLower) > -1 || this._isConjunction(prefixLower))) {
                        if (this.prefix) {
                            if (!this.isAsianName) {
                                this.prefix += ' ';
                            }
                            this.prefix += prefix;
                        } else {
                            this.prefix = prefix;
                        }
                        parts = parts.slice(i);
                        i = parts.length;
                    }
                }
            }
            // check for suffixes
            if (parts.length > 1) {
                for (i = parts.length; i > 0; i--) {
                    suffixArray = parts.slice(-i);
                    suffix = suffixArray.join(this.isAsianName ? '' : ' ');
                    suffixLower = suffix.toLowerCase();
                    suffixLower = suffixLower.replace(/[\.]/g, ''); // ignore periods
                    if (JSUtils.isArray(this.info.suffixes) &amp;&amp; JSUtils.indexOf(this.info.suffixes, suffixLower) > -1) {
                        if (this.suffix) {
                            if (!this.isAsianName &amp;&amp; !isPunct(this.suffix.charAt(0))) {
                                this.suffix = ' ' + this.suffix;
                            }
                            this.suffix = suffix + this.suffix;
                        } else {
                            this.suffix = suffix;
                        }
                        parts = parts.slice(0, parts.length - i);
                        i = parts.length;
                    }
                }
            }

            if (hpSuffix) {
                this.suffix = (this.suffix &amp;&amp; this.suffix + hpSuffix) || hpSuffix;
            }

            // adjoin auxillary words to their headwords
            if (parts.length > 1 &amp;&amp; !this.isAsianName) {
                parts = this._joinAuxillaries(parts, this.isAsianName);
            }

            if (this.isAsianName) {
                this._parseAsianName(parts, currentLanguage);
            } else {
                this._parseWesternName(parts);
            }

            this._joinNameArrays();
        }
    }

    /**
     * @return {number}
     *
    _findSequence: function(parts, hash, isAsian) {
        let sequence, sequenceLower, sequenceArray, aux = [], i, ret = {};

        if (parts.length > 0 &amp;&amp; hash) {
            //console.info("_findSequence: finding sequences");
            for (let start = 0; start &lt; parts.length-1; start++) {
                for ( i = parts.length; i > start; i-- ) {
                    sequenceArray = parts.slice(start, i);
                    sequence = sequenceArray.join(isAsian ? '' : ' ');
                    sequenceLower = sequence.toLowerCase();
                    sequenceLower = sequenceLower.replace(/[,\.]/g, '');  // ignore commas and periods

                    //console.info("_findSequence: checking sequence: '" + sequenceLower + "'");

                    if ( sequenceLower in hash ) {
                        ret.match = sequenceArray;
                        ret.start = start;
                        ret.end = i;
                        return ret;
                        //console.info("_findSequence: Found sequence '" + sequence + "' New parts list is " + JSON.stringify(parts));
                    }
                }
            }
        }

        return undefined;
    }
    */

    /**
     * @param {Array} parts
     * @param {Array} names
     * @param {boolean} isAsian
     * @param {boolean=} noCompoundPrefix
     * @private
     */
    _findPrefix(parts, names, isAsian, noCompoundPrefix) {
        let i, prefix, prefixLower, prefixArray, aux = [];

        if (parts.length > 0 &amp;&amp; names) {
            for (i = parts.length; i > 0; i--) {
                prefixArray = parts.slice(0, i);
                prefix = prefixArray.join(isAsian ? '' : ' ');
                prefixLower = prefix.toLowerCase();
                prefixLower = prefixLower.replace(/[,\.]/g, ''); // ignore commas and periods

                if (prefixLower in names) {
                    aux = aux.concat(isAsian ? prefix : prefixArray);
                    if (noCompoundPrefix) {
                        // don't need to parse further. Just return it as is.
                        return aux;
                    }
                    parts = parts.slice(i);
                    i = parts.length + 1;
                }
            }
        }

        return aux;
    }

    /**
     * @private
     */
    _findSuffix(parts, names, isAsian) {
        let i, j, seq = "";

        for (i = 0; i &lt; names.length; i++) {
            if (parts.length >= names[i].length) {
                j = 0;
                while (j &lt; names[i].length &amp;&amp; parts[parts.length - j] === names[i][names[i].length - j]) {
                    j++;
                }
                if (j >= names[i].length) {
                    seq = parts.slice(parts.length - j).join(isAsian ? "" : " ") + (isAsian ? "" : " ") + seq;
                    parts = parts.slice(0, parts.length - j);
                    i = -1; // restart the search
                }
            }
        }

        this.suffix = seq;
        return parts;
    }

    /**
     * Tell whether or not the given word is a conjunction in this language.
     * @param {string} word the word to test
     * @returns {boolean} true if the word is a conjunction
     * @private
     */
    _isConjunction(word) {
        return (this.info.conjunctions.and1 === word ||
            this.info.conjunctions.and2 === word ||
            this.info.conjunctions.or1 === word ||
            this.info.conjunctions.or2 === word ||
            ("&amp;" === word) ||
            ("+" === word));
    }

    /**
     * Find the last instance of 'and' in the name
     * @param {Array.&lt;string>} parts
     * @returns {number}
     * @private
     */
    _findLastConjunction(parts) {
        let conjunctionIndex = -1,
            index, part;

        for (index = 0; index &lt; parts.length; index++) {
            part = parts[index];
            if (typeof (part) === 'string') {
                part = part.toLowerCase();
                // also recognize English
                if ("and" === part || "or" === part || "&amp;" === part || "+" === part) {
                    conjunctionIndex = index;
                }
                if (this._isConjunction(part)) {
                    conjunctionIndex = index;
                }
            }
        }
        return conjunctionIndex;
    }

    /**
     * @private
     * @param {Array.&lt;string>} parts the current array of name parts
     * @param {boolean} isAsian true if the name is being parsed as an Asian name
     * @return {Array.&lt;string>} the remaining parts after the prefixes have been removed
     */
    _extractPrefixes(parts, isAsian) {
        let i = this._findPrefix(parts, this.info.prefixes, isAsian);
        if (i > 0) {
            this.prefix = parts.slice(0, i).join(isAsian ? "" : " ");
            return parts.slice(i);
        }
        // prefixes not found, so just return the array unmodified
        return parts;
    }

    /**
     * @param {Array.&lt;string>} parts the current array of name parts
     * @param {boolean} isAsian true if the name is being parsed as an Asian name
     * @return {Array.&lt;string>} the remaining parts after the suffices have been removed
     * @private
     */
    _extractSuffixes(parts, isAsian) {
        let i = this._findSuffix(parts, this.info.suffixes, isAsian);
        if (i > 0) {
            this.suffix = parts.slice(i).join(isAsian ? "" : " ");
            return parts.slice(0, i);
        }
        // suffices not found, so just return the array unmodified
        return parts;
    }

    /**
     * Adjoin auxillary words to their head words.
     * @param {Array.&lt;string>} parts the current array of name parts
     * @param {boolean} isAsian true if the name is being parsed as an Asian name
     * @return {Array.&lt;string>} the parts after the auxillary words have been plucked onto their head word
     * @private
     */
    _joinAuxillaries(parts, isAsian) {
        let start, i, prefixArray, prefix, prefixLower;

        if (this.info.auxillaries &amp;&amp; (parts.length > 2 || this.prefix)) {
            for (start = 0; start &lt; parts.length - 1; start++) {
                for (i = parts.length; i > start; i--) {
                    prefixArray = parts.slice(start, i);
                    prefix = prefixArray.join(' ');
                    prefixLower = prefix.toLowerCase();
                    prefixLower = prefixLower.replace(/[,\.]/g, ''); // ignore commas and periods

                    if (prefixLower in this.info.auxillaries) {
                        parts.splice(start, i + 1 - start, prefixArray.concat(parts[i]));
                        i = start;
                    }
                }
            }
        }

        return parts;
    }

    /**
     * Recursively join an array or string into a long string.
     * @private
     */
    _joinArrayOrString(part) {
        let i;
        if (typeof (part) === 'object') {
            for (i = 0; i &lt; part.length; i++) {
                part[i] = this._joinArrayOrString(part[i]);
            }
            let ret = "";
            part.forEach(function (segment) {
                if (ret.length > 0 &amp;&amp; !isPunct(segment.charAt(0))) {
                    ret += ' ';
                }
                ret += segment;
            });

            return ret;
        }

        return part;
    }

    /**
     * @private
     */
    _joinNameArrays() {
        let prop;
        for (prop in this) {

            if (this[prop] !== undefined &amp;&amp; typeof (this[prop]) === 'object' &amp;&amp; JSUtils.isArray(this[prop])) {

                this[prop] = this._joinArrayOrString(this[prop]);
            }
        }
    }

    /**
     * @private
     */
    _parseAsianName(parts, language) {
        let familyNameArray = this._findPrefix(parts, this.info.knownFamilyNames, true, typeof(this.singleFamilyName) !== 'undefined' ? this.singleFamilyName : this.info.noCompoundFamilyNames);
        let tempFullName = parts.join('');

        if (familyNameArray &amp;&amp; familyNameArray.length > 0) {
            this.familyName = familyNameArray.join('');
            this.givenName = parts.slice(this.familyName.length).join('');

            //Overide parsing rules if spaces are found in korean
            if (language === "ko" &amp;&amp; tempFullName.search(/\s*[/\s]/) > -1 &amp;&amp; !this.suffix) {
                this._parseKoreanName(tempFullName);
            }
        } else if (this.locale.getLanguage() === "ja") {
            this._parseJapaneseName(parts);
        } else if (this.suffix || this.prefix) {
            this.familyName = parts.join('');
        } else {
            this.givenName = parts.join('');
        }
    }

    /**
     * @private
     */
    _parseKoreanName(name) {
        let tempName = name;

        let spaceSplit = tempName.split(" ");
        let spceCount = spaceSplit.length;
        let fistSpaceIndex = tempName.indexOf(" ");
        let lastSpaceIndex = tempName.lastIndexOf(" ");

        if (spceCount === 2) {
            this.familyName = spaceSplit[0];
            this.givenName = tempName.slice(fistSpaceIndex, tempName.length);
        } else {
            this.familyName = spaceSplit[0];
            this.middleName = tempName.slice(fistSpaceIndex, lastSpaceIndex);
            this.givenName = tempName.slice(lastSpaceIndex, tempName.length);
        }

    }

    /**
     * @private
     */
    _parseJapaneseName(parts) {
        if (this.suffix &amp;&amp; this.suffix.length > 1 &amp;&amp; this.info.honorifics.indexOf(this.suffix)>-1) {
            if (parts.length === 1) {
                if (withinRange(parts[0], "cjk")) {
                    this.familyName = parts[0];
                } else {
                    this.givenName = parts[0];
                }
                return;
            } else if (parts.length === 2) {
                this.familyName = parts.slice(0,parts.length).join("")
                return;
            }
        }
        if (parts.length > 1) {
            let fn = "";
            for (let i = 0; i &lt; parts.length; i++) {
                if (withinRange(parts[i], "cjk")) {
                    fn += parts[i];
                } else if (fn.length > 1 &amp;&amp; withinRange(parts[i], "hiragana")) {
                    this.familyName = fn;
                    this.givenName = parts.slice(i,parts.length).join("");
                    return;
                } else {
                    break;
                }
            }
        }
        if (parts.length === 1) {
            this.familyName = parts[0];
        } else if (parts.length === 2) {
            this.familyName = parts[0];
            this.givenName = parts[1];
        } else if (parts.length === 3) {
            this.familyName = parts[0];
            this.givenName = parts.slice(1,parts.length).join("");
        } else if (parts.length > 3) {
            this.familyName = parts.slice(0,2).join("")
            this.givenName = parts.slice(2,parts.length).join("");
        }
    }

    /**
     * @private
     */
    _parseSpanishName(parts) {
        let conjunctionIndex;

        if (parts.length === 1) {
            if (this.prefix || typeof (parts[0]) === 'object') {
                this.familyName = parts[0];
            } else {
                this.givenName = parts[0];
            }
        } else if (parts.length === 2) {
            // we do G F
            this.givenName = parts[0];
            this.familyName = parts[1];
        } else if (parts.length === 3) {
            conjunctionIndex = this._findLastConjunction(parts);
            // if there's an 'and' in the middle spot, put everything in the first name
            if (conjunctionIndex === 1) {
                this.givenName = parts;
            } else {
                // else, do G F F
                this.givenName = parts[0];
                this.familyName = parts.slice(1);
            }
        } else if (parts.length > 3) {
            //there are at least 4 parts to this name

            conjunctionIndex = this._findLastConjunction(parts);
            ////console.log("@@@@@@@@@@@@@@@@"+conjunctionIndex)
            if (conjunctionIndex > 0) {
                // if there's a conjunction that's not the first token, put everything up to and
                // including the token after it into the first name, the last 2 tokens into
                // the family name (if they exist) and everything else in to the middle name
                // 0 1 2 3 4 5
                // G A G
                // G A G F
                // G G A G
                // G A G F F
                // G G A G F
                // G G G A G
                // G A G M F F
                // G G A G F F
                // G G G A G F
                // G G G G A G
                this.givenName = parts.splice(0, conjunctionIndex + 2);
                if (parts.length > 1) {
                    this.familyName = parts.splice(parts.length - 2, 2);
                    if (parts.length > 0) {
                        this.middleName = parts;
                    }
                } else if (parts.length === 1) {
                    this.familyName = parts[0];
                }
            } else {
                this.givenName = parts.splice(0, 1);
                this.familyName = parts.splice(parts.length - 2, 2);
                this.middleName = parts;
            }
        }
    }

    /**
     * @private
     */
    _parseIndonesianName(parts) {
        let conjunctionIndex;

        if (parts.length === 1) {
            //if (this.prefix || typeof(parts[0]) === 'object') {
            //this.familyName = parts[0];
            //} else {
            this.givenName = parts[0];
            //}
            //} else if (parts.length === 2) {
            // we do G F
            //this.givenName = parts[0];
            //this.familyName = parts[1];
        } else if (parts.length >= 2) {
            //there are at least 3 parts to this name

            conjunctionIndex = this._findLastConjunction(parts);
            if (conjunctionIndex > 0) {
                // if there's a conjunction that's not the first token, put everything up to and
                // including the token after it into the first name, the last 2 tokens into
                // the family name (if they exist) and everything else in to the middle name
                // 0 1 2 3 4 5
                // G A G
                // G A G F
                // G G A G
                // G A G F F
                // G G A G F
                // G G G A G
                // G A G M F F
                // G G A G F F
                // G G G A G F
                // G G G G A G
                this.givenName = parts.splice(0, conjunctionIndex + 2);
                if (parts.length > 1) {
                    //this.familyName = parts.splice(parts.length-2, 2);
                    //if ( parts.length > 0 ) {
                    this.middleName = parts;
                }
                //} else if (parts.length === 1) {
                //    this.familyName = parts[0];
                //}
            } else {
                this.givenName = parts.splice(0, 1);
                //this.familyName = parts.splice(parts.length-2, 2);
                this.middleName = parts;
            }
        }
    }

    /**
     * @private
     */
    _parseGenericWesternName(parts) {
        /* Western names are parsed as follows, and rules are applied in this
         * order:
         *
         * G
         * G F
         * G M F
         * G M M F
         * P F
         * P G F
         */
        let conjunctionIndex;

        if (parts.length === 1) {
            if (this.prefix || typeof (parts[0]) === 'object') {
                // already has a prefix, so assume it goes with the family name like "Dr. Roberts" or
                // it is a name with auxillaries, which is almost always a family name
                this.familyName = parts[0];
            } else {
                this.givenName = parts[0];
            }
        } else if (parts.length === 2) {
            // we do G F
            if (this.info.order == 'fgm') {
                this.givenName = parts[1];
                this.familyName = parts[0];
            } else if (this.info.order == "gmf" || typeof (this.info.order) == 'undefined') {
                this.givenName = parts[0];
                this.familyName = parts[1];
            }
        } else if (parts.length >= 3) {
            //find the first instance of 'and' in the name
            conjunctionIndex = this._findLastConjunction(parts);

            if (conjunctionIndex > 0) {
                // if there's a conjunction that's not the first token, put everything up to and
                // including the token after it into the first name, the last token into
                // the family name (if it exists) and everything else in to the middle name
                // 0 1 2 3 4 5
                // G A G M M F
                // G G A G M F
                // G G G A G F
                // G G G G A G
                //if(this.order == "gmf") {
                this.givenName = parts.slice(0, conjunctionIndex + 2);

                if (conjunctionIndex + 1 &lt; parts.length - 1) {
                    this.familyName = parts.splice(parts.length - 1, 1);
                    ////console.log(this.familyName);
                    if (conjunctionIndex + 2 &lt; parts.length - 1) {
                        this.middleName = parts.slice(conjunctionIndex + 2, parts.length - conjunctionIndex - 3);
                    }
                } else if (this.info.order == "fgm") {
                    this.familyName = parts.slice(0, conjunctionIndex + 2);
                    if (conjunctionIndex + 1 &lt; parts.length - 1) {
                        this.middleName = parts.splice(parts.length - 1, 1);
                        if (conjunctionIndex + 2 &lt; parts.length - 1) {
                            this.givenName = parts.slice(conjunctionIndex + 2, parts.length - conjunctionIndex - 3);
                        }
                    }
                }
            } else if (this.info.order === "fgm") {
                this.givenName = parts[1];
                this.middleName = parts.slice(2);
                this.familyName = parts[0];
            } else {
                this.givenName = parts[0];
                this.middleName = parts.slice(1, parts.length - 1);
                this.familyName = parts[parts.length - 1];
            }
        }
    }

     /**
     * parse patrinomic name from the russian names
     * @param {Array.&lt;string>} parts the current array of name parts
     * @return number  index of the part which contains patronymic name
     * @private
     */
    _findPatronymicName(parts) {
        let index, part;
        for (index = 0; index &lt; parts.length; index++) {
            part = parts[index];
            if (typeof (part) === 'string') {
                part = part.toLowerCase();

                let subLength = this.info.patronymicName.length;
                while(subLength--) {
                    if(part.indexOf(this.info.patronymicName[subLength])!== -1 )
                        return index;
                }
            }
        }
        return -1;
    }

    /**
     * find if the given part is patronymic name
     *
     * @param {string} part string from name parts @
     * @return number index of the part which contains familyName
     * @private
     */
    _isPatronymicName(part) {
        let pName;
        if ( typeof (part) === 'string') {
            pName = part.toLowerCase();

            let subLength = this.info.patronymicName.length;
            while (subLength--) {
                if (pName.indexOf(this.info.patronymicName[subLength]) !== -1)
                    return true;
            }
        }
        return false;
    }

    /**
     * find family name from the russian name
     *
     * @param {Array.&lt;string>} parts the current array of name parts
     * @return boolean true if patronymic, false otherwise
     * @private
     */
    _findFamilyName(parts) {
        let index, part, substring;
        for (index = 0; index &lt; parts.length; index++) {
            part = parts[index];

            if ( typeof (part) === 'string') {
                part = part.toLowerCase();
                let length = part.length - 1;

                if (this.info.familyName.indexOf(part) !== -1) {
                    return index;
                } else if (part[length] === 'в' || part[length] === 'н' ||
                    part[length] === 'й') {
                    substring = part.slice(0, -1);
                    if (this.info.familyName.indexOf(substring) !== -1) {
                        return index;
                    }
                } else if ((part[length - 1] === 'в' &amp;&amp; part[length] === 'а') ||
                    (part[length - 1] === 'н' &amp;&amp; part[length] === 'а') ||
                    (part[length - 1] === 'а' &amp;&amp; part[length] === 'я')) {
                    substring = part.slice(0, -2);
                    if (this.info.familyName.indexOf(substring) !== -1) {
                        return index;
                    }
                }
            }
        }
        return -1;
    }

    /**
     * parse russian name
     *
     * @param {Array.&lt;string>} parts the current array of name parts
     * @returns {Name} the parsed name
     * @private
     */
    _parseRussianName(parts) {
        let conjunctionIndex, familyIndex = -1;

        if (parts.length === 1) {
            if (this.prefix || typeof (parts[0]) === 'object') {
                // already has a prefix, so assume it goes with the family name
                // like "Dr. Roberts" or
                // it is a name with auxillaries, which is almost always a
                // family name
                this.familyName = parts[0];
            } else {
                this.givenName = parts[0];
            }
        } else if (parts.length === 2) {
            // we do G F
            if (this.info.order === 'fgm') {
                this.givenName = parts[1];
                this.familyName = parts[0];
            } else if (this.info.order === "gmf") {
                this.givenName = parts[0];
                this.familyName = parts[1];
            } else if ( typeof (this.info.order) === 'undefined') {
                if (this._isPatronymicName(parts[1]) === true) {
                    this.middleName = parts[1];
                    this.givenName = parts[0];
                } else if ((familyIndex = this._findFamilyName(parts)) !== -1) {
                    if (familyIndex === 1) {
                        this.givenName = parts[0];
                        this.familyName = parts[1];
                    } else {
                        this.familyName = parts[0];
                        this.givenName = parts[1];
                    }

                } else {
                    this.givenName = parts[0];
                    this.familyName = parts[1];
                }

            }
        } else if (parts.length >= 3) {
            // find the first instance of 'and' in the name
            conjunctionIndex = this._findLastConjunction(parts);
            let patronymicNameIndex = this._findPatronymicName(parts);
            if (conjunctionIndex > 0) {
                // if there's a conjunction that's not the first token, put
                // everything up to and
                // including the token after it into the first name, the last
                // token into
                // the family name (if it exists) and everything else in to the
                // middle name
                // 0 1 2 3 4 5
                // G A G M M F
                // G G A G M F
                // G G G A G F
                // G G G G A G
                // if(this.order == "gmf") {
                this.givenName = parts.slice(0, conjunctionIndex + 2);

                if (conjunctionIndex + 1 &lt; parts.length - 1) {
                    this.familyName = parts.splice(parts.length - 1, 1);
                    // //console.log(this.familyName);
                    if (conjunctionIndex + 2 &lt; parts.length - 1) {
                        this.middleName = parts.slice(conjunctionIndex + 2,
                            parts.length - conjunctionIndex - 3);
                    }
                } else if (this.order == "fgm") {
                    this.familyName = parts.slice(0, conjunctionIndex + 2);
                    if (conjunctionIndex + 1 &lt; parts.length - 1) {
                        this.middleName = parts.splice(parts.length - 1, 1);
                        if (conjunctionIndex + 2 &lt; parts.length - 1) {
                            this.givenName = parts.slice(conjunctionIndex + 2,
                                parts.length - conjunctionIndex - 3);
                        }
                    }
                }
            } else if (patronymicNameIndex !== -1) {
                this.middleName = parts[patronymicNameIndex];

                if (patronymicNameIndex === (parts.length - 1)) {
                    this.familyName = parts[0];
                    this.givenName = parts.slice(1, patronymicNameIndex);
                } else {
                    this.givenName = parts.slice(0, patronymicNameIndex);

                    this.familyName = parts[parts.length - 1];
                }
            } else {
                this.givenName = parts[0];

                this.middleName = parts.slice(1, parts.length - 1);

                this.familyName = parts[parts.length - 1];
            }
        }
    }


    /**
     * @private
     */
    _parseWesternName(parts) {

        if (this.locale.getLanguage() === "es" || this.locale.getLanguage() === "pt") {
            // in spain and mexico and portugal, we parse names differently than in the rest of the world
            // because of the double family names
            this._parseSpanishName(parts);
        } else if (this.locale.getLanguage() === "ru") {
            /*
             * In Russian, names can be given equally validly as given-family
             * or family-given. Use the value of the "order" property of the
             * constructor options to give the default when the order is ambiguous.
             */
            this._parseRussianName(parts);
        } else if (this.locale.getLanguage() === "id") {
            // in indonesia, we parse names differently than in the rest of the world
            // because names don't have family names usually.
            this._parseIndonesianName(parts);
        } else {
            this._parseGenericWesternName(parts);
        }
    }

    /**
     * When sorting names with auxiliary words (like "van der" or "de los"), determine
     * which is the "head word" and return a string that can be easily sorted by head
     * word. In English, names are always sorted by initial characters. In places like
     * the Netherlands or Germany, family names are sorted by the head word of a list
     * of names rather than the first element of that name.
     * @return {string|undefined} a string containing the family name[s] to be used for sorting
     * in the current locale, or undefined if there is no family name in this object
     */
    getSortFamilyName() {
        let name,
            auxillaries,
            auxString,
            parts,
            i;

        // no name to sort by
        if (!this.familyName) {
            return undefined;
        }

        // first break the name into parts
        if (this.info) {
            if (this.info.sortByHeadWord) {
                if (typeof (this.familyName) === 'string') {
                    name = this.familyName.replace(/\s+/g, ' '); // compress multiple whitespaces
                    parts = name.trim().split(' ');
                } else {
                    // already split
                    parts = this.familyName;
                }

                auxillaries = this._findPrefix(parts, this.info.auxillaries, false);
                if (auxillaries &amp;&amp; auxillaries.length > 0) {
                    if (typeof (this.familyName) === 'string') {
                        auxString = auxillaries.join(' ');
                        name = this.familyName.substring(auxString.length + 1) + ', ' + auxString;
                    } else {
                        name = parts.slice(auxillaries.length).join(' ') +
                            ', ' +
                            parts.slice(0, auxillaries.length).join(' ');
                    }
                }
            } else if (this.info.knownFamilyNames &amp;&amp; this.familyName) {
                parts = this.familyName.split('');
                let familyNameArray = this._findPrefix(parts, this.info.knownFamilyNames, true, this.info.noCompoundFamilyNames);
                name = "";
                for (i = 0; i &lt; familyNameArray.length; i++) {
                    name += (this.info.knownFamilyNames[familyNameArray[i]] || "");
                }
            }
        }

        return name || this.familyName;
    }

    getHeadFamilyName() {}

    /**
     * Return a shallow copy of the current instance.
     * @protected
     */
    clone() {
        return new Name(this);
    }
}

export default Name;</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Wed Oct 12 2022 23:55:04 GMT-0700 (Pacific Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
